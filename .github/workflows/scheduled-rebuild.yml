name: Scheduled Dependency Update Rebuild

on:
  schedule:
    # Run every Saturday at 2 AM UTC
    - cron: '0 2 * * 6'
  workflow_dispatch:  # Allow manual trigger

env:
  DOCKER_IMAGE: chasmarshall/pdfautomagic

jobs:
  check-and-rebuild:
    runs-on: ubuntu-latest
    permissions:
      contents: write  # Required for git tag push and release creation

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Get all tags

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Get current latest version
        id: current_version
        run: |
          # Get the latest tag
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v1.0.0")
          echo "latest_tag=$LATEST_TAG" >> $GITHUB_OUTPUT
          echo "Current latest version: $LATEST_TAG"

      - name: Get base image digest
        id: base_image
        run: |
          # Pull ubuntu:24.04 and get its current digest
          docker pull ubuntu:24.04
          BASE_DIGEST=$(docker image inspect ubuntu:24.04 --format '{{index .RepoDigests 0}}' 2>/dev/null || echo "ubuntu:24.04@unknown")
          echo "Base image: $BASE_DIGEST"
          echo "digest=$BASE_DIGEST" >> $GITHUB_OUTPUT

      - name: Build test image to check versions
        run: |
          docker build -t test-build .

      - name: Extract new build info
        id: new_info
        run: |
          # Get version info from newly built image (override entrypoint)
          # Extract only version numbers to avoid false positives from formatting changes
          NEW_VERSIONS=$(docker run --rm --entrypoint bash test-build -c '
            echo "base_image_digest=${{ steps.base_image.outputs.digest }}"
            echo "ocrmypdf=$(ocrmypdf --version 2>&1 | grep -oE "[0-9]+\.[0-9]+\.[0-9]+" | head -1)"
            echo "tesseract=$(tesseract --version 2>&1 | grep -oE "[0-9]+\.[0-9]+\.[0-9]+" | head -1)"
            echo "rclone=$(rclone version 2>&1 | grep -oE "v[0-9]+\.[0-9]+\.[0-9]+" | head -1)"
            echo "base_version=$(cat /etc/os-release | grep VERSION_ID | grep -oE "[0-9]+\.[0-9]+")"
          ')

          echo "New versions:"
          echo "$NEW_VERSIONS"

          # Save to file for comparison (sorted for consistent ordering)
          echo "$NEW_VERSIONS" | sort > new_versions.txt

          # Add to summary
          echo "### üì¶ New Build Information" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "$NEW_VERSIONS" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

      - name: Pull current latest image and extract info
        id: current_info
        continue-on-error: true
        run: |
          # Try to pull current latest image
          if docker pull ${{ env.DOCKER_IMAGE }}:latest 2>/dev/null; then
            # Override entrypoint to get version info
            # Use same extraction pattern as new build for consistent comparison
            CURRENT_VERSIONS=$(docker run --rm --entrypoint bash ${{ env.DOCKER_IMAGE }}:latest -c '
              echo "base_image_digest=${{ steps.base_image.outputs.digest }}"
              echo "ocrmypdf=$(ocrmypdf --version 2>&1 | grep -oE "[0-9]+\.[0-9]+\.[0-9]+" | head -1)"
              echo "tesseract=$(tesseract --version 2>&1 | grep -oE "[0-9]+\.[0-9]+\.[0-9]+" | head -1)"
              echo "rclone=$(rclone version 2>&1 | grep -oE "v[0-9]+\.[0-9]+\.[0-9]+" | head -1)"
              echo "base_version=$(cat /etc/os-release | grep VERSION_ID | grep -oE "[0-9]+\.[0-9]+")"
            ')

            echo "Current published versions:"
            echo "$CURRENT_VERSIONS"
            echo "$CURRENT_VERSIONS" | sort > current_versions.txt

            # Add to summary
            echo "### üìã Current Published Version" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "$CURRENT_VERSIONS" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
          else
            echo "No current image found, will push new version"
            echo "" > current_versions.txt
          fi

      - name: Compare versions and decide
        id: compare
        run: |
          if [ -f current_versions.txt ] && [ -s current_versions.txt ]; then
            if diff -q new_versions.txt current_versions.txt > /dev/null; then
              echo "Versions are identical, no rebuild needed"
              echo "needs_rebuild=false" >> $GITHUB_OUTPUT

              echo "## ‚úÖ No Rebuild Needed" >> $GITHUB_STEP_SUMMARY
              echo "Package versions are identical to current latest image" >> $GITHUB_STEP_SUMMARY
            else
              echo "Versions differ, rebuilding..."
              echo "needs_rebuild=true" >> $GITHUB_OUTPUT

              echo "## üîÑ Rebuild Required" >> $GITHUB_STEP_SUMMARY
              echo "### Changes Detected:" >> $GITHUB_STEP_SUMMARY
              echo '```diff' >> $GITHUB_STEP_SUMMARY
              diff current_versions.txt new_versions.txt || true >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "No existing image, will create initial version"
            echo "needs_rebuild=true" >> $GITHUB_OUTPUT
          fi

      - name: Calculate new version
        if: steps.compare.outputs.needs_rebuild == 'true'
        id: new_version
        run: |
          LATEST_TAG="${{ steps.current_version.outputs.latest_tag }}"

          # Extract version numbers (e.g., v1.0.2 -> 1 0 2)
          VERSION="${LATEST_TAG#v}"
          MAJOR=$(echo $VERSION | cut -d. -f1)
          MINOR=$(echo $VERSION | cut -d. -f2)
          PATCH=$(echo $VERSION | cut -d. -f3)

          # Increment patch version
          NEW_PATCH=$((PATCH + 1))
          NEW_VERSION="v${MAJOR}.${MINOR}.${NEW_PATCH}"

          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "Incrementing $LATEST_TAG -> $NEW_VERSION (dependency updates)"

          echo "## üì¶ New Version" >> $GITHUB_STEP_SUMMARY
          echo "**$NEW_VERSION** (was $LATEST_TAG)" >> $GITHUB_STEP_SUMMARY

      - name: Extract metadata for Docker
        if: steps.compare.outputs.needs_rebuild == 'true'
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKER_IMAGE }}
          tags: |
            type=raw,value=${{ steps.new_version.outputs.new_version }}
            type=raw,value=latest

      - name: Build and push updated image
        if: steps.compare.outputs.needs_rebuild == 'true'
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Create git tag
        if: steps.compare.outputs.needs_rebuild == 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          NEW_VERSION="${{ steps.new_version.outputs.new_version }}"

          git tag -a "$NEW_VERSION" -m "Automated dependency update rebuild

          Updated package versions detected during scheduled rebuild.

          $(cat new_versions.txt)

          ü§ñ Automated build by GitHub Actions"

          git push origin "$NEW_VERSION"

      - name: Create GitHub Release
        if: steps.compare.outputs.needs_rebuild == 'true'
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.new_version.outputs.new_version }}
          name: ${{ steps.new_version.outputs.new_version }} - Dependency Updates
          body: |
            ## Automated Dependency Update

            This release contains updated dependencies from the Ubuntu 24.04 repositories.

            ### Package Versions
            ```
            $(cat new_versions.txt)
            ```

            ### Changes from Previous Version
            ```diff
            $(diff current_versions.txt new_versions.txt || echo "Initial release")
            ```

            ü§ñ This release was automatically created by scheduled dependency updates.
          draft: false
          prerelease: false

      - name: Summary
        run: |
          if [ "${{ steps.compare.outputs.needs_rebuild }}" == "true" ]; then
            echo "‚úÖ Successfully rebuilt and tagged ${{ steps.new_version.outputs.new_version }}"
          else
            echo "‚ÑπÔ∏è No rebuild needed - versions unchanged"
          fi
